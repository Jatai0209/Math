# 卡特兰数-公式推导


## 本文逻辑递进-关系

教科书的一般教学逻辑【反人类正常思维的教学】
	
		 一般式公式 → 递推式 
	 		 ↓ 
			证明
			 ↓
			形象
		↙ 	 ↓	  ↘
	应用1   应用2   应用3

---

历史上发现的逻辑顺序【先形象，再抽象】

	应用1   应用2   应用3
		↘	↓	↙
		   形象
			↓
		  递推式
			↓
		   证明
	        ↓
	    一般式公式

---

本文采用 先形象，再抽象的方式来进行 讲解。

↙↖↗↘
↓
←	
↑
→

## 图象化

折线法
>
http://blog.sina.com.cn/s/blog_6917f47301010cno.html


## 具象化

>
n个元素的二叉查找树有多少种:

	For example: f(3) = 5
	Given n = 3, there are a total of 5 unique BST's. 
	
	   1         3     3      2      1
	    \       /     /      / \      \
	     3     2     1      1   3      2
	    /     /       \                 \
	   2     1         2                 3
	
	题目来源:
	https://leetcode.com/problems/unique-binary-search-trees/
	http://www.lintcode.com/zh-cn/problem/unique-binary-search-trees/

---
>
n个元素全部入栈并且全部出栈的所有可能顺序:

---
>
n对括号的所有合法的组成

## 抽象


## 递推式

	f(0) = 1;
	f(1) = 1;
	k = [1 ~ n+1]
	f(n+1) = f(0)f(n) + f(1)f(n-1) + ... + f(k-1)f(n-(k-1)) + ... + f(n)f(0);


## 证明


## 一般式

前25项为 （OEIS中的数列A000108）: 

	1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 
	58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 
	24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, 

	f(19) = 1767263190 =   0110 1001 0101 0110 0100 1011 1101 0110;		// 共占用31位-第32位为0
	f(20) = 6564120420 = 1 1000 0111 0100 0000 1000 0111 0110 0100;		// 共占用33位
	int型(32位) 只能装的下 f(19)
	unsign int型(32位) 就连f(20)都装不下了。 

## 代码计算式

非大数版本：

	int numTrees(int n) {
        int f[20] = {0};
        f[0] = 1;
        f[1] = 1;
        
        for(int i = 2; i <= n; ++i) {
            for(int j = 0; j < i; ++j) {
                f[i] += f[j] * f[i-j-1];
            }
        }
        
        return f[n]; 
    }


大数版本：